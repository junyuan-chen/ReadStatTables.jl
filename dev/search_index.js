var documenterSearchIndex = {"docs":
[{"location":"man/table-interface/#Table-Interface","page":"Table Interface","title":"Table Interface","text":"","category":"section"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"This page provides further details on the interface of ReadStatTable.","category":"page"},{"location":"man/table-interface/#ReadStatTables.ReadStatTable","page":"Table Interface","title":"ReadStatTables.ReadStatTable","text":"ReadStatTable{Cols} <: Tables.AbstractColumns\n\nA Tables.jl-compatible column table that collects data read from or written to a Stata, SAS or SPSS file processed with the ReadStat C library. File-level and variable-level metadata can be retrieved and modified via methods compatible with DataAPI.jl. For a ReadStatTable constructed by readstat, Cols is either ReadStatColumns or ChainedReadStatColumns depending on whether multiple threads are used for parsing the data file. For a ReadStatTable constructed for writestat, Cols is allowed to be a column table type for any Tables.jl-compatible table. See also ReadStatMeta and ReadStatColMeta for the included metadata.\n\n\n\n\n\n","category":"type"},{"location":"man/table-interface/#Data-Columns","page":"Table Interface","title":"Data Columns","text":"","category":"section"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"As a subtype of Tables.AbstractColumns, commonly used methods including those defined in Tables.jl are implemented for ReadStatTable.","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"using ReadStatTables, Tables\ntb = readstat(\"data/sample.dta\")","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"A column can be accessed either by name or by position via multiple methods:","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"tb.mynum\ntb[:mynum]\nTables.getcolumn(tb, :mynum)\ntb[2]\nTables.getcolumn(tb, 2)","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"To check whether a column is in a ReadStatTable:","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"haskey(tb, :mynum)\nhaskey(tb, 2)","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"To check the number of rows in a ReadStatTable:","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"Tables.rowcount(tb)\nsize(tb, 1)","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"To check the number of columns in a ReadStatTable:","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"length(tb)\nsize(tb, 2)","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"Iterating a ReadStatTable directly results in iteration across columns:","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"for col in tb\n    println(eltype(col))\nend","category":"page"},{"location":"man/table-interface/#Data-Values","page":"Table Interface","title":"Data Values","text":"","category":"section"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"In addition to retrieving the data columns, it is possible to directly retrieve and modify individual data values via getindex and setindex!:","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"tb[1,1]\ntb[1,1] = \"f\"\ntb[1,1]\ntb[1,:mylabl]\ntb[1,:mylabl] = 2\ntb[1,:mylabl]\ntb[1,:mydate]\ntb[1,:dtime]","category":"page"},{"location":"man/table-interface/","page":"Table Interface","title":"Table Interface","text":"Notice that for data columns with value labels, these methods only deal with the underlying values and disregard the value labels. Similarly, for data columns with a date/time format, the numerical values instead of the converted Date/DateTime values are returned.","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"ReadStatTables.jl is licensed under the MIT license.","category":"page"},{"location":"license/","page":"License","title":"License","text":"MIT License\n\nCopyright (c) 2021 Junyuan Chen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.","category":"page"},{"location":"man/date-and-time-values/#Date-and-Time-Values","page":"Date and Time Values","title":"Date and Time Values","text":"","category":"section"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"Date and time values in the data files are recognized based on the format of each variable. Many data/time formats can be recognized without user intervention.[1] In case certain date/time formats are not recognized, they can be added easily.","category":"page"},{"location":"man/date-and-time-values/#Translating-Date-and-Time-Values","page":"Date and Time Values","title":"Translating Date and Time Values","text":"","category":"section"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"For all date/time formats from Stata, SAS and SPSS, the date and time values are stored as the numbers of periods elapsed since a reference date or time point (epoch) chosen by the software. Therefore, knowing the reference data/time and the length of a single period is sufficient for uncovering the represented date/time values for a given format.","category":"page"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"info: Info\nTwo exceptions are Stata format \"%tw\" for weeks and \"%ty\" for years. Stata always counts the week numbers starting from the first day of a year. Each year always consists of 52 weeks. Any remaining day at the end of a year is counted as the 52th week within that year. Conversion for a variable with format \"%tw\" is therefore handled differently. For \"%ty\", the recorded numerical values are simply the calendar years without any transformation. A variable with format \"%ty\" is not converted to Julia Date or DateTime.","category":"page"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"If a variable is in a date/time format that can be recognized, the values will be displayed as Julia Date or DateTime when printing a ReadStatTable. Notice that the underlying numerical values are preserved and the conversion to the Julia Date or DateTime happens only lazily via a MappedArray when working with a ReadStatTable.","category":"page"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"using ReadStatTables, DataFrames\ntb = readstat(\"data/sample.dta\")\ntb.mydate\ntb.mydate.data\ncolmetadata(tb, :mydate, \"format\")","category":"page"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"The variable-level metadata key named format informs ReadStatTable whether the variable represents date/time and how the numerical values should be interpreted. Changing the format directly affects how the values are displayed, although the numerical values remain unchanged.","category":"page"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"colmetadata!(tb, :mydate, \"format\", \"%tm\")\ntb.mydate\ncolmetadata!(tb, :mydate, \"format\", \"%8.0f\")\ntb.mydate","category":"page"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"Copying a ReadStatTable (e.g., converting to a DataFrame) may drop the underlying numerical values. Hence, users who wish to directly work with the underlying numerical values may want to preserve the ReadStatTable generated from the data file.","category":"page"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"df = DataFrame(tb)\ndf.mydate","category":"page"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"In the above example, df.mydate only contains the Date values and the underlying numerical values are lost when constructing the DataFrame.","category":"page"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"The full lists of recognized date/time formats for the statistical software are stored as dictionary keys; while the associated values are tuples of reference date/time and period length.[2] If a date/time format is not found in the dictionary, no type conversion will be attempted. Additional formats may be added by inserting key-value pairs to the relevant dictionaries.","category":"page"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"ReadStatTables.stata_dt_formats\nReadStatTables.sas_dt_formats[\"MMDDYY\"]\nReadStatTables.spss_dt_formats[\"TIME\"]","category":"page"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"[1]: For Stata, all date/time formats except \"%tC\" and \"%d\" are supported. The only difference between the \"%tC\" format and the \"%tc\" format is that \"%tC\" takes into account leap seconds while \"%tc\" does not. Since the DateTime type in the Dates module does not allow leap seconds, only the \"%tc\" format is supported. The \"%d\" format that appears in earlier versions of Stata is no longer documented in recent versions. For SAS and SPSS, the coverage of date/time formats might be less comprehensive.","category":"page"},{"location":"man/date-and-time-values/","page":"Date and Time Values","title":"Date and Time Values","text":"[2]: For Stata, the reference for date/time value translation is the official Stata documentation. Only the first three characters in the format strings affect the coding. For SAS and SPSS, the reference is pyreadstat/_readstat_parser.pyx.","category":"page"},{"location":"man/getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"An overview of the usage of ReadStatTables.jl is provided below. For instructions on installation, see Installation.","category":"page"},{"location":"man/getting-started/#Reading-a-Data-File","page":"Getting Started","title":"Reading a Data File","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Suppose we have a Stata .dta file located at data/sample.dta. To read this file into Julia:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"using ReadStatTables\ntb = readstat(\"data/sample.dta\")","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Here is how we read the above result:[1]","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Variable names from the data file are displayed in the first row.\nElement type of each variable is displayed below the corresponding variable name.\nThe values of each variable are displayed column-wise starting from the third row.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Some additional details to be noted:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"If a variable contains any missing value, there is a question mark ? in the displayed element type.\nBy default, all missing values are treated as missing, a special value in Julia.\nThe date and time values have been translated into Date and DateTime respectively.[2]\nLabels instead of the numeric values are displayed for variables with value labels.\nLabeled{Int8} is an abbreviation for LabeledValue{Int8}.","category":"page"},{"location":"man/getting-started/#Accessing-Individual-Objects","page":"Getting Started","title":"Accessing Individual Objects","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"A vector of all variable names can be obtained as follows:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"columnnames(tb)","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"To retrieve the array containing data for a specific variable:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"tb.mylabl","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nThe returned array is exactly the same array holding the data for the table. Therefore, modifying elements in the returned array will also change the data in the table. To avoid such changes, please copy the array first.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Metadata for the data file can be accessed from tb using methods that are compatible with DataAPI.jl.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"metadata(tb)\ncolmetadata(tb)\ncolmetadata(tb, :myord)","category":"page"},{"location":"man/getting-started/#Type-Conversions","page":"Getting Started","title":"Type Conversions","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"The interface provided by ReadStatTables.jl allows basic tasks. In case more complicated operations are needed, it is easy to convert the objects into other types.","category":"page"},{"location":"man/getting-started/#Converting-ReadStatTable","page":"Getting Started","title":"Converting ReadStatTable","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"The table returned by readstat is a ReadStatTable. Converting a ReadStatTable to another table type is easy, thanks to the widely supported Tables.jl interface.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"For example, to convert a ReadStatTable to a DataFrame from DataFrames.jl:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"using DataFrames\ndf = DataFrame(tb)","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Metadata contained in a ReadStatTable are preserved in the converted DataFrame when working with DataFrames.jl version v1.4.0 or above, which supports the same DataAPI.jl interface for metadata:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"metadata(df)\ncolmetadata(df, :myord)","category":"page"},{"location":"man/getting-started/#Converting-LabeledArray","page":"Getting Started","title":"Converting LabeledArray","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Variables with value labels are stored in LabeledArrays. To convert a LabeledArray to another array type, we may either obtain an array of LabeledValues or collect the values and labels separately. The data values can be directly retrieved by calling refarray:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"refarray(tb.mylabl)","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"note: Note\nThe array returned by refarray is exactly the same array underlying the LabeledArray. Therefore, modifying the elements of the array will also mutate the values in the associated LabeledArray.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"If only the value labels are needed, we can obtain an iterator of the value labels via valuelabels. For example, to convert a LabeledArray to a CategoricalArray from CategoricalArrays.jl:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"using CategoricalArrays\nCategoricalArray(valuelabels(tb.mylabl))","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"It is also possible to only convert the type of the underlying data values:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"convertvalue(Int32, tb.mylabl)","category":"page"},{"location":"man/getting-started/#ReadStatTables.convertvalue","page":"Getting Started","title":"ReadStatTables.convertvalue","text":"convertvalue(T, x::LabeledArray)\n\nConvert the type of data values contained in x to T. This method is equivalent to convert(AbstractArray{LabeledValue{T, K}, N}}, x).\n\n\n\n\n\n","category":"function"},{"location":"man/getting-started/#Writing-a-Data-File","page":"Getting Started","title":"Writing a Data File","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"To write a table to a supported data file format:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"# Create a data frame for illustration\ndf = DataFrame(readstat(\"data/alltypes.dta\")); emptycolmetadata!(df)\nout = writestat(\"data/write_alltypes.dta\", df)","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"The returned table out contains the actual data (including metadata) that are exposed to the writer.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Value labels attached to a LabeledArray are always preserved in the output file. If the input table contains any column of type CategoricalArray or PooledArray, value labels are created and written automatically by default:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"using PooledArrays\ndf[!,:vbyte] = CategoricalArray(valuelabels(df.vbyte))\ndf[!,:vint] = PooledArray(valuelabels(df.vint))\nout = writestat(\"data/write_alltypes.dta\", df)","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Notice that in the returned table, the columns vbyte and vint are LabeledArrays:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"out.vbyte\nout.vint","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"It is possible to specify the format of certain variables. This can be important, for example, for variables representing date/time. In the above example, a default format has been selected:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"out.vdate\ncolmetadata(out, :vdate, \"format\")","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"To specify a different format, a convenient approach is to specify the varformat keyword argument:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"out2 = writestat(\"data/write_alltypes.dta\", df, varformat=Dict(:vdate=>\"%tm\"));\nout2.vdate\ncolmetadata(out2, :vdate, \"format\")","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Notice that since the format \"%tm\" is for months, the day within a month has been ignored and becomes 1 for the printed value of Date in the above example.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"info: Info\nWhen a variable has a Stata format \"%tw\", \"%tm\", \"%tq\" or \"%th\", a displayed Date is always the first day within the corresponding Stata period. In particular, Stata counts week numbers starting from the first day of each year and hence a displayed Date may not correspond to the first day of a calendar week.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"warning: Warning\nThe write support is experimental and requires further testing. Caution should be taken when writing the data files.","category":"page"},{"location":"man/getting-started/#More-Options","page":"Getting Started","title":"More Options","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"The behavior of readstat can be adjusted by passing keyword arguments:","category":"page"},{"location":"man/getting-started/#ReadStatTables.readstat","page":"Getting Started","title":"ReadStatTables.readstat","text":"readstat(filepath; kwargs...)\n\nReturn a ReadStatTable that collects data (including metadata) from a supported data file located at filepath.\n\nSupported File Formats\n\nStata: .dta\nSAS: .sas7bdat and .xpt\nSPSS: .sav and por\n\nKeywords\n\next = lowercase(splitext(filepath)[2]): extension of data file for choosing the parser.\nusecols::Union{ColumnSelector, Nothing} = nothing: only collect data from the specified columns (variables); collect all columns if usecols=nothing.\nrow_limit::Union{Integer, Nothing} = nothing: restrict the total number of rows to be read; read all rows if row_limit=nothing.\nrow_offset::Integer = 0: skip the specified number of rows.\nntasks::Union{Integer, Nothing} = nothing: number of tasks spawned to read data file in concurrent chunks with multiple threads; with ntasks being nothing or smaller than 1, select a default value based on the size of data file and the number of threads available (Threads.nthreads()); not applicable to .xpt and .por files where row count is unknown from metadata.\napply_value_labels::Bool = true: apply value labels to the associated columns.\ninlinestring_width::Integer = ext âˆˆ (\".sav\", \".por\") ? 0 : 32: use a fixed-width string type that can be stored inline for any string variable with width below inlinestring_width and pool_width; a non-positive value avoids using any inline string type; not recommended for SPSS files.\npool_width::Integer = 64: only attempt to use PooledArray for string variables with width of at least 64.\npool_thres::Integer = 500: do not use PooledArray for string variables if the number of unique values exceeds pool_thres; a non-positive value avoids using PooledArray.\nfile_encoding::Union{String, Nothing} = nothing: manually specify the file character encoding; need to be an iconv-compatible name.\nhandler_encoding::Union{String, Nothing} = nothing: manually specify the handler character encoding; default to UTF-8.\n\n\n\n\n\n","category":"function"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"The accepted types of values for selecting certain variables (data columns) are shown below:","category":"page"},{"location":"man/getting-started/#ReadStatTables.ColumnIndex","page":"Getting Started","title":"ReadStatTables.ColumnIndex","text":"ColumnIndex\n\nA type union for values accepted by readstat and ReadStatTable for selecting a column. A column can be selected either with the column name as Symbol or String; or with an integer (Int) index based on the position in a table. See also ColumnSelector.\n\n\n\n\n\n","category":"type"},{"location":"man/getting-started/#ReadStatTables.ColumnSelector","page":"Getting Started","title":"ReadStatTables.ColumnSelector","text":"ColumnSelector\n\nA type union for values accepted by readstat for selecting a single column or multiple columns. The accepted values can be of type ColumnIndex, a UnitRange of integers, an array or a set of ColumnIndex.\n\n\n\n\n\n","category":"type"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"File-level metadata can be obtained without reading the entire data file:","category":"page"},{"location":"man/getting-started/#ReadStatTables.readstatmeta","page":"Getting Started","title":"ReadStatTables.readstatmeta","text":"readstatmeta(filepath; kwargs...)\n\nReturn a ReadStatMeta that collects file-level metadata without reading the full data from a supported data file located at filepath. See also readstatallmeta.\n\nSupported File Formats\n\nStata: .dta\nSAS: .sas7bdat and .xpt\nSPSS: .sav and por\n\nKeywords\n\next = lowercase(splitext(filepath)[2]): extension of data file for choosing the parser.\nfile_encoding::Union{String, Nothing} = nothing: manually specify the file character encoding; need to be an iconv-compatible name.\nhandler_encoding::Union{String, Nothing} = nothing: manually specify the handler character encoding; default to UTF-8.\n\n\n\n\n\n","category":"function"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"To additionally collect variable-level metadata and all value labels:","category":"page"},{"location":"man/getting-started/#ReadStatTables.readstatallmeta","page":"Getting Started","title":"ReadStatTables.readstatallmeta","text":"readstatallmeta(filepath; kwargs...)\n\nReturn all metadata including value labels without reading the full data from a supported data file located at filepath. The four returned objects are for file-level metadata, variable names, variable-level metadata and value labels respectively. See also readstatmeta.\n\nSupported File Formats\n\nStata: .dta\nSAS: .sas7bdat and .xpt\nSPSS: .sav and por\n\nKeywords\n\next = lowercase(splitext(filepath)[2]): extension of data file for choosing the parser.\nusecols::Union{ColumnSelector, Nothing} = nothing: only collect variable-level metadata from the specified columns (variables); collect all columns if usecols=nothing.\nfile_encoding::Union{String, Nothing} = nothing: manually specify the file character encoding; need to be an iconv-compatible name.\nhandler_encoding::Union{String, Nothing} = nothing: manually specify the handler character encoding; default to UTF-8.\n\n\n\n\n\n","category":"function"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"For writing tables to data files, one may gain more control by first converting a table to a ReadStatTable:","category":"page"},{"location":"man/getting-started/#ReadStatTables.writestat","page":"Getting Started","title":"ReadStatTables.writestat","text":"writestat(filepath, table; ext = lowercase(splitext(filepath)[2]), kwargs...)\n\nWrite a Tables.jl-compatible table to filepath as a data file supported by ReadStat. File format is determined based on the extension contained in filepath and may be overriden by the ext keyword.\n\nAny user-provided table is converted to a ReadStatTable first before being handled by a ReadStat writer. Therefore, to gain fine-grained control over the content to be written, especially for metadata, one may directly work with a ReadStatTable (possibly converted from another table type such as DataFrame from DataFrames.jl) before passing it to writestat. Alternatively, one may pass any keyword argument accepted by a constructor of ReadStatTable to writestat. The actual ReadStatTable handled by the writer is returned after the writer finishes.\n\nSupported File Formats\n\nStata: .dta\nSAS: .sas7bdat and .xpt (Note: SAS may not recognize the produced .sas7bdat files due to a known limitation with ReadStat.)\nSPSS: .sav and por\n\nConversion\n\nFor data values, Julia objects are converted to the closest ReadStat type for either numerical values or strings. However, depending on the file format of the output file, a data column may be written in a different type when the closest ReadStat type is not supported.\n\nFor metadata, if the user-provided table is not a ReadStatTable, an attempt will be made to collect table-level or column-level metadata with a key that matches a metadata field in ReadStatMeta or ReadStatColMeta via the metadata and colmetadata interface defined by DataAPI.jl. If the table is a ReadStatTable, then the associated metadata will be written as long as their values are compatible with the format of the output file. Value labels associated with a LabeledArray are always preserved even when the name of the dictionary of value labels is not specified in metadata (column name will be used by default). If a column is of an array type that makes use of DataAPI.refpool (e.g., CategoricalArray and PooledArray), value labels will be generated automatically by default (with keyword refpoolaslabel set to be true) and the underlying numerical reference values instead of the values returned by getindex are written to files (with value labels attached).\n\n\n\n\n\n","category":"function"},{"location":"man/getting-started/#ReadStatTables.ReadStatTable-Tuple{Any, AbstractString}","page":"Getting Started","title":"ReadStatTables.ReadStatTable","text":"ReadStatTable(table, ext::AbstractString; kwargs...)\n\nConstruct a ReadStatTable by wrapping a Tables.jl-compatible column table for a supported file format with extension ext. An attempt is made to collect table-level or column-level metadata with a key that matches a metadata field in ReadStatMeta or ReadStatColMeta via the metadata and colmetadata interface defined by DataAPI.jl.\n\nThis method is used by writestat when the provided table is not already a ReadStatTable. Hence, it is useful for gaining fine-grained control over the content to be written. Metadata may be manually specified with keyword arguments.\n\nAny missing existing in string columns will be replaced by an empty string \"\". A column with element type Missing is treated as a column with empty strings.\n\nKeywords\n\ncopycols::Bool = true: copy data columns to ReadStatColumns; this is required for writing columns of date/time values (that are not already represented by numeric values).\nrefpoolaslabel::Bool = true: generate value labels for columns of an array type that makes use of DataAPI.refpool (e.g., CategoricalArray and PooledArray).\nvallabels::Dict{Symbol, Dict} = Dict{Symbol, Dict}(): a dictionary of all value label dictionaries indexed by their names.\nhasmissing::Vector{Bool} = Vector{Bool}(): a vector of indicators for whether any missing value present in the corresponding column; irrelavent for writing tables.\nmeta::ReadStatMeta = ReadStatMeta(): file-level metadata.\ncolmeta::ColMetaVec = ReadStatColMetaVec(): variable-level metadata stored in a StructArray of ReadStatColMetas; values are always overwritten.\nvarformat::Union{Dict{Symbol,String}, Nothing} = nothing: specify variable-level format for certain variables with the key being the variable name (as Symbol) and value being the format string.\nstyles::Dict{Symbol, Symbol} = _default_metastyles(): metadata styles.\nmaxdispwidth::Integer = 60: maximum display_width set for any variable.\n\n\n\n\n\n","category":"method"},{"location":"man/getting-started/#ReadStatTables.ReadStatTable-Tuple{ReadStatTable, AbstractString}","page":"Getting Started","title":"ReadStatTables.ReadStatTable","text":"ReadStatTable(table::ReadStatTable, ext::AbstractString; kwargs...)\n\nConstruct a ReadStatTable from an existing ReadStatTable for a supported file format with extension ext.\n\nKeywords\n\nupdate_width::Bool = true: determine the storage width for each string variable by checking the actual data columns instead of any existing metadata value.\n\n\n\n\n\n","category":"method"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"[1]: The printed output is generated with PrettyTables.jl.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"[2]: The time types Date and DateTime are from the Dates module of Julia.","category":"page"},{"location":"man/value-labels/#Value-Labels","page":"Value Labels","title":"Value Labels","text":"","category":"section"},{"location":"man/value-labels/","page":"Value Labels","title":"Value Labels","text":"Value labels collected from the data files are incorporated into the associated data columns via a custom array type LabeledArray.","category":"page"},{"location":"man/value-labels/#LabeledValue-and-LabeledArray","page":"Value Labels","title":"LabeledValue and LabeledArray","text":"","category":"section"},{"location":"man/value-labels/","page":"Value Labels","title":"Value Labels","text":"LabeledValue and LabeledArray are designed to imitate how variables associated with value labels are represented in the original data files from the statistical software. The former wraps a data array with a reference to the value labels; while the latter wraps a single data value. The element of a LabeledArray is always a LabeledValue. However, a LabeledValue obtained from a LabeledArray is only constructed when being retrieved via getindex for efficient storage.","category":"page"},{"location":"man/value-labels/","page":"Value Labels","title":"Value Labels","text":"Some noteworthy distinctions of a LabeledArray are highlighted below:","category":"page"},{"location":"man/value-labels/","page":"Value Labels","title":"Value Labels","text":"Values are never re-encoded when a LabeledArray is constructed.[1]\nIt is allowed for some values in a LabeledArray to not have a value label.[2]\nA label is always a String even when it is associated with missing.","category":"page"},{"location":"man/value-labels/","page":"Value Labels","title":"Value Labels","text":"In essence, a LabeledArray is simply an array of data values (typically numbers) bundled with a dictionary of value labels. There is no restriction imposed on the correspondence between the data values and value labels. Namely, a data value in a LabeledArray is not necessarily attached with a value label from the associated dictionary; while the key of a value label contained in the dictionary may not match any array element. Furthermore, the dictionary of value labels may be switched and shared across different LabeledArrays. When setting values in a LabeledArray, the array of data values are modified directly with no additional check on the associated dictionary of value labels. For this reason, the functionality of a LabeledArray is not equivalent to that of an array type designed for categorical data (e.g., CategoricalArray from CategoricalArrays.jl). They are not complete substitutes for each other.","category":"page"},{"location":"man/value-labels/","page":"Value Labels","title":"Value Labels","text":"More details are below:","category":"page"},{"location":"man/value-labels/#ReadStatTables.LabeledValue","page":"Value Labels","title":"ReadStatTables.LabeledValue","text":"LabeledValue{T, K}\n\nValue of type T associated with a dictionary of value labels with keys of type K. If a value v is not euqal (==) to a key in the dictionary, then string(v) is taken as the value label. See also LabeledArray.\n\nThe value underlying a LabeledValue can be accessed via unwrap. The value label can be obtained by calling valuelabel or converting a LabeledValue to String via convert. The dictionary of value labels (typically assoicated with a data column) can be accessed via getvaluelabels.\n\nComparison operators ==, isequal, <, isless and isapprox compare the underlying value of type T and disregard any value label. To compare the value label, use valuelabel to retrieve the label first.\n\nExamples\n\njulia> lbls = Dict{Int,String}(0=>\"a\", 1=>\"a\");\n\njulia> v0 = LabeledValue(0, lbls)\n0 => a\n\njulia> v1 = LabeledValue(1, lbls)\n1 => a\n\njulia> vm = LabeledValue(missing, lbls)\nmissing => missing\n\njulia> v0 == v1\nfalse\n\njulia> v1 == 1\ntrue\n\njulia> isnan(v1)\nfalse\n\njulia> isequal(vm, missing)\ntrue\n\njulia> unwrap(v0)\n0\n\njulia> valuelabel(v1) == \"a\"\ntrue\n\njulia> getvaluelabels(v1) === lbls\ntrue\n\n\n\n\n\n","category":"type"},{"location":"man/value-labels/#ReadStatTables.LabeledArray","page":"Value Labels","title":"ReadStatTables.LabeledArray","text":"LabeledArray{V, N, A<:AbstractArray{V, N}, K} <: AbstractArray{LabeledValue{V, K}, N}\n\nN-dimensional dense array with elements associated with value labels.\n\nLabeledArray provides functionality that is similar to what value labels achieve in statistical software such as Stata. When printed to REPL, a LabeledArray just looks like an array of value labels. Yet, only the underlying values of type V are stored in an array of type A. The associated value labels are looked up from a dictionary of type Dict{K, String}. If a value v is not equal (==) to a key in the dictionary, then string(v) is taken as the value label. The elements of type LabeledValue{V, K} are only constructed lazily when they are retrieved.\n\nThe array of values underlying a LabeledArray can be accessed via refarray. The dictionary of value labels assoicated with a LabeledArray can be accessed via getvaluelabels. An iterator over the value labels for each element, which has the same array shape as the LabeledArray, can be obtained via valuelabels.\n\nEquality comparison (==) involving a LabeledArray only compares the underlying values and disregard any value label. To compare the value labels, use valuelabels to obtain the labels first.\n\nAdditional array methods such as push!, insert!, deleteat!, append! are supported for LabeledVector. They are applied on the underlying array of values retrieved via refarray and do not modify the dictionary of value labels.\n\nFor convenience, LabeledArray(x::AbstractArray{<:AbstractString}, ::Type{T}=Int32) converts a string array to a LabeledArray by encoding the string values with integers of the specified type (Int32 by default).\n\nExamples\n\njulia> lbls1 = Dict(1=>\"a\", 2=>\"b\");\n\njulia> lbls2 = Dict(1.0=>\"p\", 2.0=>\"q\");\n\njulia> x = LabeledArray([0, 1, 2], lbls1)\n3-element LabeledVector{Int64, Vector{Int64}, Int64}:\n 0 => 0\n 1 => a\n 2 => b\n\njulia> y = LabeledArray([0.0, 1.0, 2.0], lbls2)\n3-element LabeledVector{Float64, Vector{Float64}, Float64}:\n 0.0 => 0.0\n 1.0 => p\n 2.0 => q\n\njulia> x == y\ntrue\n\njulia> x == 0:2\ntrue\n\njulia> refarray(x)\n3-element Vector{Int64}:\n 0\n 1\n 2\n\njulia> getvaluelabels(x)\nDict{Int64, String} with 2 entries:\n  2 => \"b\"\n  1 => \"a\"\n\njulia> valuelabels(x) == [\"0\", \"a\", \"b\"]\ntrue\n\njulia> push!(x, 2)\n4-element LabeledVector{Int64, Vector{Int64}, Int64}:\n 0 => 0\n 1 => a\n 2 => b\n 2 => b\n\njulia> push!(x, 3 => \"c\")\n5-element LabeledVector{Int64, Vector{Int64}, Int64}:\n 0 => 0\n 1 => a\n 2 => b\n 2 => b\n 3 => c\n\njulia> deleteat!(x, 4:5)\n3-element LabeledVector{Int64, Vector{Int64}, Int64}:\n 0 => 0\n 1 => a\n 2 => b\n\njulia> append!(x, [0, 1, 2])\n6-element LabeledVector{Int64, Vector{Int64}, Int64}:\n 0 => 0\n 1 => a\n 2 => b\n 0 => 0\n 1 => a\n 2 => b\n\njulia> v = [\"a\", \"b\", \"c\"];\n\njulia> LabeledArray(v, Int16)\n3-element LabeledVector{Int16, Vector{Int16}, Union{Char, Int32}}:\n 1 => a\n 2 => b\n 3 => c\n\n\n\n\n\n","category":"type"},{"location":"man/value-labels/#ReadStatTables.LabeledVector","page":"Value Labels","title":"ReadStatTables.LabeledVector","text":"LabeledVector{V, A, K} <: AbstractVector{LabeledValue{V, K}}\n\nAlias for LabeledArray{V, 1, A, K}.\n\n\n\n\n\n","category":"type"},{"location":"man/value-labels/#ReadStatTables.LabeledMatrix","page":"Value Labels","title":"ReadStatTables.LabeledMatrix","text":"LabeledMatrix{V, A, K} <: AbstractMatrix{LabeledValue{V, K}}\n\nAlias for LabeledArray{V, 2, A, K}.\n\n\n\n\n\n","category":"type"},{"location":"man/value-labels/#Accessing-Values-and-Labels","page":"Value Labels","title":"Accessing Values and Labels","text":"","category":"section"},{"location":"man/value-labels/","page":"Value Labels","title":"Value Labels","text":"For LabeledValue, the underlying data value can be retrieved via unwrap. The value label can be obtained via valuelabel or conversion to String. For LabeledArray, the underlying data values can be retrieved via refarray. An iterator of value labels that maintains the shape of the LabeledArray can be obtained by calling valuelabels.","category":"page"},{"location":"man/value-labels/#DataAPI.unwrap","page":"Value Labels","title":"DataAPI.unwrap","text":"unwrap(x::LabeledValue)\n\nReturn the value underlying the value label of x.\n\n\n\n\n\n","category":"function"},{"location":"man/value-labels/#ReadStatTables.valuelabel","page":"Value Labels","title":"ReadStatTables.valuelabel","text":"valuelabel(x::LabeledValue)\n\nReturn the value label associated with x.\n\n\n\n\n\n","category":"function"},{"location":"man/value-labels/#ReadStatTables.getvaluelabels","page":"Value Labels","title":"ReadStatTables.getvaluelabels","text":"getvaluelabels(x::LabeledValue)\n\nReturn the dictionary of value labels (typically assoicated with a data column) attached to x.\n\n\n\n\n\ngetvaluelabels(x::LabeledArray)\ngetvaluelabels(x::SubArray{<:Any, <:Any, <:LabeledArray})\ngetvaluelabels(x::Base.ReshapedArray{<:Any, <:Any, <:LabeledArray})\ngetvaluelabels(x::SubArray{<:Any, <:Any, <:Base.ReshapedArray{<:Any, <:Any, <:LabeledArray}})\n\nReturn the dictionary of value labels attached to x.\n\n\n\n\n\ngetvaluelabels(tb::ReadStatTable)\ngetvaluelabels(tb::ReadStatTable, name::Symbol)\n\nReturn a dictionary of all value label dictionaries contained in tb obtained from the data file. Return a specific dictionary of value labels if a name is specified.\n\nEach dictionary of value labels is associated with a name that may appear in the variable-level metadata under the key vallabel for identifying the dictionary of value labels attached to each data column. The same dictionary may be associated with multiple data columns. Modifying the metadata value of vallabel for a data column switches the associated value labels for the data column. If the metadata value is set to Symbol(\"\"), the data column is not associated with any value label.\n\n\n\n\n\n","category":"function"},{"location":"man/value-labels/#DataAPI.refarray","page":"Value Labels","title":"DataAPI.refarray","text":"refarray(x::LabeledArray)\nrefarray(x::SubArray{<:Any, <:Any, <:LabeledArray})\nrefarray(x::Base.ReshapedArray{<:Any, <:Any, <:LabeledArray})\nrefarray(x::SubArray{<:Any, <:Any, <:Base.ReshapedArray{<:Any, <:Any, <:LabeledArray}})\n\nReturn the array of values underlying a LabeledArray.\n\n\n\n\n\n","category":"function"},{"location":"man/value-labels/#ReadStatTables.valuelabels","page":"Value Labels","title":"ReadStatTables.valuelabels","text":"valuelabels(x::AbstractArray{<:LabeledValue})\n\nReturn an iterator over the value labels of all elements in x. The returned object is a subtype of AbstractArray with the same size of x.\n\nThe iterator can be used to collect value labels to arrays while discarding the underlying values.\n\nExamples\n\njulia> x = LabeledArray([1, 2, 3], Dict(1=>\"a\", 2=>\"b\"))\n3-element LabeledVector{Int64, Vector{Int64}, Int64}:\n 1 => a\n 2 => b\n 3 => 3\n\njulia> lbls = valuelabels(x)\n3-element ReadStatTables.LabelIterator{LabeledVector{Int64, Vector{Int64}, Int64}, 1}:\n \"a\"\n \"b\"\n \"3\"\n\njulia> collect(lbls)\n3-element Vector{String}:\n \"a\"\n \"b\"\n \"3\"\n\njulia> CategoricalArray(lbls)\n3-element CategoricalArray{String,1,UInt32}:\n \"a\"\n \"b\"\n \"3\"\n\n\n\n\n\n","category":"function"},{"location":"man/value-labels/","page":"Value Labels","title":"Value Labels","text":"[1]: The values themselves are sometimes meaningful and should not be treated as reference values.","category":"page"},{"location":"man/value-labels/","page":"Value Labels","title":"Value Labels","text":"[2]: In case a label is requested for a value that is not associated with a label, the value is converted to String.","category":"page"},{"location":"man/metadata/#Metadata","page":"Metadata","title":"Metadata","text":"","category":"section"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"File-level metadata associated with a data file are collected in a ReadStatMeta; while variable-level metadata associated with each data column are collected in ReadStatColMetas. These metadata objects are stored in a ReadStatTable along with the data columns and can be accessed via methods compatible with DataAPI.jl.","category":"page"},{"location":"man/metadata/#File-Level-Metadata","page":"Metadata","title":"File-Level Metadata","text":"","category":"section"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Each ReadStatTable contains a ReadStatMeta for file-level metadata.","category":"page"},{"location":"man/metadata/#ReadStatTables.ReadStatMeta","page":"Metadata","title":"ReadStatTables.ReadStatMeta","text":"ReadStatMeta <: AbstractMetaDict\n\nA collection of file-level metadata associated with a data file processed with ReadStat.\n\nMetadata can be retrieved and modified from the associated ReadStatTable via methods compatible with DataAPI.jl. A dictionary-like interface is also available for directly working with ReadStatMeta.\n\nFields\n\nrow_count::Int: number of rows returned by ReadStat parser; being -1 if not available in metadata; may reflect the value set with the row_limit parser option instead of the actual number of rows in the data file.\nvar_count::Int: number of data columns returned by ReadStat parser.\ncreation_time::DateTime: timestamp for file creation.\nmodified_time::DateTime: timestamp for file modification.\nfile_format_version::Int: version number of file format.\nfile_format_is_64bit::Bool: indicator for 64-bit file format; only relevant to SAS.\ncompression::readstat_compress_t: file compression mode; only relevant to certain file formats.\nendianness::readstat_endian_t: endianness of data file.\ntable_name::String: name of the data table; only relevant to .xpt format.\nfile_label::String: label of data file.\nfile_encoding::String: character encoding of data file.\nnotes::Vector{String}: notes attached to data file.\nfile_ext::String: file extension of data file.\n\n\n\n\n\n","category":"type"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"To retrieve the ReadStatMeta from the ReadStatTable:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"metadata(tb)","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"The value associated with a specific metadata key can be retrieved via:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"metadata(tb, \"file_label\")\nmetadata(tb, \"file_label\", style=true)","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"To obtain a complete list of metadata keys:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"metadatakeys(tb)","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Metadata contained in a ReadStatMeta can be modified, optionally with a metadata style set at the same time:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"metadata!(tb, \"file_label\", \"A file label\", style=:default)","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Since ReadStatMeta has a dictionary-like interface, one can also directly work with it:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"m = metadata(tb)\nkeys(m)\nm[\"file_label\"]\nm[\"file_label\"] = \"A new file label\"\ncopy(m)","category":"page"},{"location":"man/metadata/#Variable-Level-Metadata","page":"Metadata","title":"Variable-Level Metadata","text":"","category":"section"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"A ReadStatColMeta is associated with each data column for variable-level metadata.","category":"page"},{"location":"man/metadata/#ReadStatTables.ReadStatColMeta","page":"Metadata","title":"ReadStatTables.ReadStatColMeta","text":"ReadStatColMeta <: AbstractMetaDict\n\nA collection of variable-level metadata associated with a data column processed with ReadStat.\n\nMetadata can be retrieved and modified from the associated ReadStatTable via methods compatible with DataAPI.jl. A dictionary-like interface is also available for directly working with ReadStatColMeta, but it does not allow modifying metadata values. An alternative way to retrive and modify the metadata is via colmetavalues.\n\nFields\n\nlabel::String: variable label.\nformat::String: variable format.\ntype::readstat_type_t: original variable type recognized by ReadStat.\nvallabel::Symbol: name of the dictionary of value labels associated with the variable; see also getvaluelabels for the effect of modifying this field.\nstorage_width::Csize_t: variable storage width in data file.\ndisplay_width::Cint: width for display.\nmeasure::readstat_measure_t: measure type of the variable; only relevant to SPSS.\nalignment::readstat_alignment_t: variable display alignment.\n\n\n\n\n\n","category":"type"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"To retrieve the ReadStatColMeta for a specified data column contained in a ReadStatTable:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"colmetadata(tb, :mylabl)","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"The value associated with a specific metadata key can be retrieved via:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"colmetadata(tb, :mylabl, \"label\")\ncolmetadata(tb, :mylabl, \"label\", style=true)","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"To obtain a complete list of metadata keys:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"colmetadatakeys(tb, :mylabl)","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Metadata contained in a ReadStatColMeta can be modified, optionally with a metadata style set at the same time:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"colmetadata!(tb, :mylabl, \"label\", \"A variable label\", style=:default)","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"A ReadStatColMeta also has a dictionary-like interface:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"m = colmetadata(tb, :mylabl)\nkeys(m)\nm[\"label\"]\ncopy(m)","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"However, it cannot be modified directly via setindex!:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"m[\"label\"] = \"A new label\"","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Instead, since the metadata associated with each key are stored consecutively in arrays internally, one may directly access the underlying array for a given metadata key:","category":"page"},{"location":"man/metadata/#ReadStatTables.colmetavalues","page":"Metadata","title":"ReadStatTables.colmetavalues","text":"colmetavalues(tb::ReadStatTable, key)\n\nReturn an array of metadata values associated with key for all columns in tb.\n\n\n\n\n\n","category":"function"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"v = colmetavalues(tb, \"label\")","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Notice that changing any value in the array returned above will affect the corresponding ReadStatColMeta:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"colmetadata(tb, :mychar, \"label\")\nv[1] = \"char\"\ncolmetadata(tb, :mychar, \"label\")","category":"page"},{"location":"man/metadata/#Metadata-Styles","page":"Metadata","title":"Metadata Styles","text":"","category":"section"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Metadata styles provide additional information on how the metadata should be processed in certain scenarios. ReadStatTables.jl does not require such information. However, specifying metadata styles can be useful when the metadata need to be transferred to some other object (e.g., DataFrame from DataFrames.jl). Packages that implement metadata-related methods compatible with DataAPI.jl are able to recognize the metadata contained in ReadStatTable.","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"By default, metadata on labels and notes have the :note style; all other metadata have the :default style. Keys for metadata with user-specified styles, along with those that have the :note style by default, are recorded in a dictionary:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"metastyle(tb)","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"All metadata associated with keys not listed above are of :default style. To modify the metadata style for those associated with a given key:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"metastyle!(tb, \"modified_time\", :note)","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"The same method is also used for variable-specific metadata. However, since the styles are only determined by the metadata keys, metadata associated with the same key always have the same style and hence are not distinguished across different columns.","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"metastyle!(tb, \"label\", :default)\ncolmetadata(tb, :mychar, \"label\", style=true)\ncolmetadata(tb, :mynum, \"label\", style=true)","category":"page"},{"location":"man/metadata/#ReadStatTables.metastyle","page":"Metadata","title":"ReadStatTables.metastyle","text":"metastyle(tb::ReadStatTable, [key::Union{Symbol, AbstractString}])\n\nReturn the specified style(s) of all metadata for table tb. If a metadata key is specified, only the style for the associated metadata are returned. By default, metadata on labels and notes have the :note style; all other metadata have the :default style.\n\nThe style of metadata is only determined by key and hence is not distinguished across different columns.\n\n\n\n\n\n","category":"function"},{"location":"man/metadata/#ReadStatTables.metastyle!","page":"Metadata","title":"ReadStatTables.metastyle!","text":"metastyle!(tb::ReadStatTable, key::Union{Symbol, AbstractString}, style::Symbol)\n\nSet the style of all metadata associated with key to style for table tb.\n\nThe style of metadata is only determined by key and hence is not distinguished across different columns.\n\n\n\n\n\n","category":"function"},{"location":"#ReadStatTables.jl","page":"Home","title":"ReadStatTables.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation site for ReadStatTables.jl!","category":"page"},{"location":"","page":"Home","title":"Home","text":"ReadStatTables.jl is a Julia package for reading and writing Stata, SAS and SPSS data files with Tables.jl-compatible tables.[1] It utilizes the ReadStat C library developed by Evan Miller for parsing and writing the data files. The same C library is also the backend of popular packages in other languages such as pyreadstat for Python and haven for R. As the Julia counterpart for similar purposes, ReadStatTables.jl leverages the state-of-the-art Julia ecosystem for usability and performance. Its read performance, especially when taking advantage of multiple threads, surpasses all related packages by a sizable margin based on the benchmark results here:","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n  <img src=\"https://raw.githubusercontent.com/junyuan-chen/ReadStatTablesBenchmarks/main/results/stable/stata_10k_500.svg\" width=\"70%\"><br>\n</p>","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ReadStatTables.jl provides the following features in addition to wrapping the C interface of ReadStat:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fast multi-threaded data collection from ReadStat parsers to a Tables.jl-compatible ReadStatTable\nInterface of file-level and variable-level metadata compatible with DataAPI.jl\nIntegration of value labels into data columns via a custom array type LabeledArray\nTranslation of date and time values into Julia time types Date and DateTime\nWrite support for Tables.jl-compatible tables (experimental)","category":"page"},{"location":"#Supported-File-Formats","page":"Home","title":"Supported File Formats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ReadStatTables.jl recognizes data files with the following file extensions at this moment:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Stata: .dta\nSAS: .sas7bdat and .xpt\nSPSS: .sav and .por","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ReadStatTables.jl can be installed with the Julia package manager Pkg. From the Julia REPL, type ] to enter the Pkg REPL and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add ReadStatTables","category":"page"},{"location":"#Known-Limitations","page":"Home","title":"Known Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The development of ReadStatTables.jl is not fully complete. The main limitations to be addressed are the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Read support for SAS value labels is temporarily absent.\nAll missing values are represented by a single value missing.[2]\nWrite support for the file formats is experimental and not fully developed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: Development for the reading capability is temporarily prioritized over that for the writing capability. Implementation for the write support only started recently and should be considered as experimental.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: The statistical software may accept multiple values for representing missing values (e.g., .a, .b,..., .z in Stata). These original values can be recognized by the parser but are not integrated into the output at this moment.","category":"page"}]
}
